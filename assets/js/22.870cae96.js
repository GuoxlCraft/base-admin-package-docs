(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{382:function(s,a,t){"use strict";t.r(a);var n=t(45),e=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"安装依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装依赖"}},[s._v("#")]),s._v(" 安装依赖")]),s._v(" "),t("p",[s._v("使用本依赖库，需要先进入依赖库根目录，运行"),t("code",[s._v("npm run build")]),s._v("打包。打出来的umd包能够通过npm发布。您可以选择发布npm的公共包，但则需要在"),t("a",{attrs:{href:"https://www.npmjs.com/",target:"_blank",rel:"noopener noreferrer"}},[s._v("npm"),t("OutboundLink")],1),s._v("上注册账号等，详细的发包流程可以阅读"),t("a",{attrs:{href:"https://www.jianshu.com/p/9325240352a4",target:"_blank",rel:"noopener noreferrer"}},[s._v("发布依赖到npm公库流程"),t("OutboundLink")],1),s._v("。")]),s._v(" "),t("p",[s._v("由于公共库发包过程复杂，这里建议使用私库方案来使用本依赖库。推荐的npm私库方案有 yalc 和 yarn/cnpm link。")]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),t("p",[s._v("使用vite搭建的业务项目，需要注意一下。vite对第三方依赖有预编译缓存的功能，为了加快esbuild的效率。因此，在依赖库拓展开发后无法更新到被引入的业务项目中去（vite优先加载node_modules中 .vite/deps 的缓存）。这使得要更新依赖库需要手动删除node_modules，重新安装。在后续，会想办法解决（困扰）。\n另外，由于npm link对依赖库中的循环引用的问题处理的不好，本依赖包不推荐使用npm link。可以尝试用cnpm link或者yarn link。")])]),s._v(" "),t("h2",{attrs:{id:"yalc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yalc"}},[s._v("#")]),s._v(" yalc")]),s._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/wclr/yalc",target:"_blank",rel:"noopener noreferrer"}},[s._v("yalc"),t("OutboundLink")],1),s._v(" 可以在本地将 npm 包模拟发布，将发布后的资源存放在一个全局存储中。然后可以通过 "),t("a",{attrs:{href:"https://github.com/wclr/yalc",target:"_blank",rel:"noopener noreferrer"}},[s._v("yalc"),t("OutboundLink")],1),s._v(" 将包添加进需要引用的项目中。")]),s._v(" "),t("p",[s._v("这时候 package.json 的依赖表中会多出一个 file:.yalc/... 的依赖包，这就是 "),t("a",{attrs:{href:"https://github.com/wclr/yalc",target:"_blank",rel:"noopener noreferrer"}},[s._v("yalc"),t("OutboundLink")],1),s._v(" 创建的特殊引用。同时也会在项目根目录创建一个 yalc.lock 确保引用资源的一致性。")]),s._v(" "),t("p",[s._v("首先您需要全局安装yalc")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("install")]),s._v(" yalc -g\n")])])]),t("p",[s._v("在依赖库根目录下执行")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" run build "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&&")]),s._v(" yalc publish\n")])])]),t("p",[s._v("在项目目录下执行")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("yalc "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("add")]),s._v(" base-admin\n")])])]),t("p",[s._v("这里会将本次构建的base-admin依赖库安装到项目中。在业务项目的根目录生成一份.yalc的目录，存放依赖包。在package.json中通过file:.yalc/...指向该包形成依赖关系。")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("  "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"dependencies"')]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"@babel/runtime"')]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"^7.16.0"')]),s._v(",\n    "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"axios"')]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"^0.24.0"')]),s._v(",\n    "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"base-admin"')]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"file:.yalc/base-admin"')]),s._v(", //yalc 生产的base-admin的依赖关系\n    "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"core-js"')]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"^3.19.0"')]),s._v(",\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),t("p",[s._v("这里补充一下yalc在依赖库更新时的用法。")]),s._v(" "),t("p",[s._v("当对本依赖库进行拓展开发时，需要变更依赖库中package.json的版本号。")])]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("  "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"name"')]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"base-admin"')]),s._v(",\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"version"')]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"1.1.0"')]),s._v(", // 在更新了依赖库之后，需要更新version的值。yalc才会进行响应\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"description"')]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"起源项目的基础依赖包"')]),s._v(",\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"main"')]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"dist/main.js"')]),s._v(",\n")])])]),t("p",[s._v("然后在依赖库根目录下执行")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" run build "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&&")]),s._v(" yalc push\n")])])]),t("p",[s._v("新版本的依赖库，会自动同步更新到所有引入该依赖库的业务项目中。")]),s._v(" "),t("h2",{attrs:{id:"yarn-link-cnpm-link"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yarn-link-cnpm-link"}},[s._v("#")]),s._v(" yarn link/cnpm link")]),s._v(" "),t("p",[s._v("这两种方式的发包流程大致相同，都是对"),t("a",{attrs:{href:"https://docs.npmjs.com/cli/v8/commands/npm-link/",target:"_blank",rel:"noopener noreferrer"}},[s._v("npm link"),t("OutboundLink")],1),s._v("的优化升级，这里就以 yarn 举例。")]),s._v(" "),t("p",[s._v("同样首先您需要全局安装yarn或者cnpm")]),s._v(" "),t("p",[s._v("在依赖库根目录下执行")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" run build "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&&")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yarn")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("link")]),s._v("\n")])])]),t("p",[s._v("此时yarn会在全局存入一份该依赖包。")]),s._v(" "),t("p",[s._v("在项目目录下执行")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yarn")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("link")]),s._v(" base-admin\n")])])]),t("p",[s._v("这里会将本次构建的base-admin依赖库安装到项目中。\n在业务项目的node_modules中添加base-admin的依赖包。")]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),t("p",[s._v("当对本依赖库进行拓展开发时，同需要变更依赖库中package.json的版本号。")])]),s._v(" "),t("p",[s._v("然后在依赖库根目录下执行")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" run build\n")])])]),t("p",[s._v("新打出来的包，会直接更新到所有引入该依赖库的业务项目中。")])])}),[],!1,null,null,null);a.default=e.exports}}]);